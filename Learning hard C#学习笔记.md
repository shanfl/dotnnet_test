第1章　你真的了解C#吗
1.1　什么是C#
1.1.1　C#语言的发展历程
1.1.2　C#能编写哪些应用程序
1.2　什么是.NET Framework
1.2.1　.NET Framework的组成
1.2.2　C#与.NET Framework的关系
1.2.3　C#代码的执行过程
1.3　归纳总结

第2章　来点C#的感觉
2.1　开发环境的搭建
2.2　创建"欢迎你"应用程序
2.2.1　创建控制台项目
2.2.2　编译和运行程序
2.2.3　对程序进行调试
2.3　归纳总结

第3章　打开C#的大门--C#语言基础
3.1　标识符和关键字
3.1.1　标识符
3.1.2　关键字
3.2　基础数据类型
3.2.1　数值类型
3.2.2　字符串类型
3.2.3　枚举类型
3.2.4　结构体类型
3.2.5　数组类型
3.3　变量和常量
3.3.1　变量的使用
3.3.2　变量的作用域
3.3.3　常量
3.4　运算符和表达式
3.4.1　运算符
3.4.2　运算符优先级
3.4.3　运算符重载
3.4.4　表达式
3.5　C#中的语句
3.5.1　条件语句
3.5.2　循环语句
3.5.3　跳转语句
3.6　归纳总结

第4章　C#中的类
4.1　什么是类
4.2　C#中如何定义一个类
4.3　类的成员
4.3.1　字段
4.3.2　属性
4.3.3　方法
4.3.4　构造函数
4.3.5　析构函数
4.3.6　索引器
4.4　类实例化
4.5　类与结构体的区别
4.6　归纳总结

第5章　首先需要明确的--C#中的面向对象编程
5.1　封装
5.2　继承
5.2.1　C#中的继承
5.2.2　密封类
5.2.3　子类的初始化顺序
5.3　多态
5.3.1　使用virtual和override关键字实现方法重写
5.3.2　阻止派生类重写虚成员
5.3.3　使用新成员隐藏基类成员
5.4　所有类的父类：System.object
5.5　归纳总结

第6章　电脑有USB接口，C#也有接口
6.1　什么是接口
6.2　如何使用接口来编程
6.2.1　接口的定义
6.2.2　继承接口
6.2.3　调用接口中的方法
6.3　显式接口实现方式
6.4　接口与抽象类
6.5　面向对象编程的应用
6.6　归纳总结

第7章　透过外表看本质--IL　语言
7.1　什么是IL
7.2　先睹为快--从"Hello World"看IL
7.2.1　工具的介绍
7.2.2　使用工具查看IL代码
7.3　教你看懂IL代码
7.3.1　IL基本类型
7.3.2　变量的声明
7.3.3　基本运算
7.3.4　IL中的流程控制
7.4　归纳总结

第8章　正式进入C#的世界--委托
8.1　C#委托是什么
8.2　委托的使用
8.3　为什么要引入委托
8.4　委托的本质
8.5　委托链
8.5.1　委托链的使用
8.5.2　从委托链中移除委托
8.6　归纳总结

第9章　事件揭秘
9.1　什么是事件
9.2　使用事件
9.2.1　如何定义事件
9.2.2　订阅和取消事件
9.2.3　扩展EventArgs类
9.3　事件的本质
9.4　归纳总结

第10章　深入理解类型
10.1　C#中的类型--值类型和引用类型
10.1.1　什么是值类型和引用类型
10.1.2　值类型与引用类型的区别
10.1.3　两大类型间的转换--装箱与拆箱
10.2　参数传递问题剖析
10.2.1　值类型参数的按值传递
10.2.2　引用类型参数的按值传递
10.2.3　string引用类型参数按值传递的特殊情况
10.2.4　值类型和引用类型参数的按引用传递
10.3　归纳总结

第11章　使类型参数化--泛型
11.1　泛型是什么
11.2　C# 2.0为什么要引入泛型
11.3　全面解析泛型
11.3.1　类型参数
11.3.2　泛型中的静态字段和静态函数问题
11.3.3　类型参数的推断
11.3.4　类型参数的约束
11.4　归纳总结

第12章　可空类型、匿名方法和迭代器
12.1　可空类型
12.1.1　可空类型简介
12.1.2　你知道空合并操作符吗
12.1.3　可空类型的装箱和拆箱操作
12.2　匿名方法
12.2.1　什么是匿名方法
12.2.2　对变量捕捉过程的剖析
12.3　迭代器
12.3.1　迭代器的简介
12.3.2　C# 1.0中如何实现迭代器
12.3.3　C# 2.0简化了迭代器的实现
12.3.4　迭代器的执行过程
12.4　归纳总结

第13章　C#的春天--C# 3.0中智能的编译器
13.1　自动实现的属性
13.2　隐式类型
13.2.1　隐式类型的局部变量
13.2.2　隐式类型数组
13.3　对象集合初始化器
13.4　匿名类型
13.5　归纳总结

第14章　不一样的编码风格--Lambda表达式
14.1　Lambda表达式简介
14.1.1　Lambda表达式的演变过程
14.1.2　Lambda表达式的使用
14.2　表达式也有树结构--表达式树
14.2.1　动态地构造一个表达式树
14.2.2　通过Lambda表达式来构造表达式树
14.2.3　如何把表达式树转换成可执行代码
14.3　归纳总结

第15章　使类的扩展更简单--扩展方法
15.1　什么是扩展方法
15.2　扩展方法的使用
15.2.1　定义扩展方法
15.2.2　调用扩展方法
15.3　编译器如何发现扩展方法
15.4　空引用也可调用扩展方法
15.4.1　拿例子说话
15.4.2　空引用上调用扩展方法揭秘
15.5　归纳总结

第16章　数据操作So easy--LINQ解析
16.1　LINQ是什么
16.2　LINQ好在哪里
16.2.1　查询表达式
16.2.2　使用Linq to Objects查询集合
16.2.3　使用Linq to XML查询XML 文件
16.3　理解LINQ的本质
16.4　归纳总结

第17章　小改动大作为--C# 4.0中的微小改动
17.1　可选参数和命名实参
17.1.1　可选参数
17.1.2　命名实参
17.1.3　COM互操作的福音
17.2　泛型的可变性
17.2.1　协变性
17.2.2　逆变性
17.2.3　协变和逆变的注意事项
17.3　归纳总结

第18章　静中有动--动态类型
18.1　动态类型简介
18.2　C#为什么要引入动态类型
18.2.1　可以减少强制类型转换的使用
18.2.2　调用Python等动态语言
18.3　动态类型约束
18.3.1　不能用来调用扩展方法
18.3.2　委托与动态类型间不能做隐式转换
18.3.3　不能调用构造函数和静态方法
18.3.4　类型声明和泛型类型参数
18.4　实现自己的动态行为
18.4.1　使用ExpandoObject来实现动态行为
18.4.2　使用DynamicObject来实现动态行为
18.4.3　使用IDynamicMetaObject-Provider接口来实现动态行为
18.5　归纳总结

第19章　你必须掌握的多线程编程
19.1　多线程编程必备知识
19.1.1　进程与线程的概念
19.1.2　线程的调度
19.1.3　线程也分前后台
19.2　线程的容器--线程池
19.2.1　线程池
19.2.2　通过线程池来实现多线程
19.2.3　协作式取消线程池线程
19.3　线程同步
19.3.1　多线程程序中存在的隐患
19.3.2　使用监视器对象实现线程同步
19.3.3　线程同步技术存在的问题
19.4　归纳总结

第20章　不得不说的异步编程
20.1　什么是异步编程
20.2　同步方式存在的问题
20.3　异步编程模型（APM）
20.4　异步编程模型--EAP
20.5　TAP又是什么
20.6　让异步编程So easy--C# 5.0 中的async和await
20.7　归纳总结

第21章　出师前闯关训练第一关--文件操作
21.1　文件操作核心类
21.1.1　File 和FileInfo类
21.1.2　Directory和DirectoryInfo类
21.2　流
21.3　对文件进行异步操作
21.4　归纳总结

第22章　出师前闯关训练第二关--网络编程
22.1　网络编程基础知识
22.1.1　网络分层总览
22.1.2　各层所使用的协议
22.1.3　网络程序的工作机制
22.2　基于TCP的网络程序的实现
22.2.1　TCP的工作过程
22.2.2　基于TCP的简单通信程序的实现
22.3　基于UDP的网络程序的实现
22.3.1　UDP的工作原理
22.3.2　UDP的优势
22.3.3　基于UDP的简单通信程序的实现
22.4　归纳总结

第23章　出师前闯关训练最后一关--使用GDI+实现属于你的截图工具
23.1　前期准备
23.1.1　什么是GDI+
23.1.2　笔、画笔和颜色
23.2　动手实现你的QQ截图工具
23.2.1　实现思路
23.2.2　瞧瞧最终结果
23.3　归纳总结